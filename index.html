<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Universe - Interactive Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #6366f1;
            --accent-color: #10b981;
            --background-dark: #0a0a0f;
            --background-light: #1a1a2e;
            --surface-color: rgba(255, 255, 255, 0.05);
            --surface-border: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.5);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--background-dark) 0%, var(--background-light) 100%);
            overflow: hidden;
            color: var(--text-primary);
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Enhanced Welcome Message */
        .welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 48px;
            max-width: 480px;
            text-align: center;
            opacity: 1;
            pointer-events: auto;
            z-index: 500;
            transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 
                0 24px 48px rgba(0, 212, 255, 0.1),
                0 12px 24px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .welcome-message.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -60%) scale(0.95);
        }

        .welcome-message h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #00d4ff 0%, #6366f1 50%, #10b981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(20deg); }
        }

        .welcome-message .subtitle {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 32px;
            line-height: 1.6;
            opacity: 0.9;
        }

        /* Enhanced Info Panel with glassmorphism */
        .info-panel {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 24px;
            max-width: 360px;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: auto;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .info-panel:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .info-panel h2 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .info-panel p {
            color: var(--text-secondary);
            font-size: 0.9em;
            line-height: 1.5;
            margin-bottom: 0;
        }

        /* Hide stats text in info panel */
        .info-panel .stats-text {
            display: none;
        }

        /* Remove tip section */
        .info-panel div:last-child {
            display: none;
        }

        /* Enhanced Controls with better visual hierarchy */
        .controls {
            position: absolute;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            pointer-events: auto;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 8px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            color: var(--text-secondary);
            padding: 14px 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            font-size: 0.9em;
            min-width: 100px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .btn:hover::before {
            transform: translateX(100%);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .btn.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-color: transparent;
            box-shadow: 
                0 4px 20px rgba(0, 212, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Enhanced close button */
        .close-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            border-radius: 12px;
            color: white;
            padding: 14px 32px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 
                0 4px 20px rgba(0, 212, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .close-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .close-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 30px rgba(0, 212, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Enhanced help button */
        .help-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: auto;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-secondary);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .help-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(0, 212, 255, 0.4);
        }

        /* Enhanced tooltip with better positioning */
        .tooltip {
            position: absolute;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            z-index: 300;
            max-width: 280px;
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.4),
                0 0 40px rgba(0, 212, 255, 0.1);
            transform: translateY(10px);
        }

        .tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: rgba(10, 10, 15, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateX(-50%) rotate(45deg);
        }

        /* Enhanced insights panel */
        .insights-panel {
            position: absolute;
            bottom: 100px;
            right: 24px;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 24px;
            width: 320px;
            pointer-events: auto;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            transform: translateX(340px);
            opacity: 0;
        }

        .insights-panel.visible {
            transform: translateX(0);
            opacity: 1;
        }

        .insight-item {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 3px solid var(--primary-color);
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .insight-item:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(-4px);
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.1);
        }

        /* Enhanced loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.6s ease;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 212, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.4);
        }

        /* Add missing loading text style */
        .loading-text {
            color: var(--text-secondary);
            margin-top: 20px;
            font-size: 1.1em;
            letter-spacing: 0.5px;
        }

        .loading-status {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-top: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Fix help overlay styles */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            padding: 20px;
        }

        .help-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Fix help content styles */
        .help-content {
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 
                0 24px 48px rgba(0, 212, 255, 0.1),
                0 12px 24px rgba(0, 0, 0, 0.4);
        }

        .help-overlay.visible .help-content {
            transform: scale(1);
        }

        .help-content h2 {
            color: var(--primary-color);
            font-size: 2em;
            margin-bottom: 24px;
            text-align: center;
            font-weight: 700;
        }

        .help-section {
            margin-bottom: 28px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .help-section h3 {
            color: var(--secondary-color);
            font-size: 1.2em;
            margin-bottom: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-section p, .help-section li {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .help-section ul {
            padding-left: 24px;
            margin-top: 12px;
        }

        .help-section li {
            margin-bottom: 10px;
        }

        .help-section strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Add missing progress bar style */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 0.5s ease;
            z-index: 200;
            width: 0%;
            display: none;
        }

        /* Add missing cluster labels styles */
        .cluster-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .cluster-label {
            position: absolute;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 12px 20px;
            color: var(--primary-color);
            font-weight: 500;
            font-size: 0.9em;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.4),
                0 0 40px rgba(0, 212, 255, 0.2);
            transform: scale(0.9) translateY(10px);
            pointer-events: none;
        }

        .cluster-label.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Improve insights panel styles */
        .insights-panel h3 {
            color: var(--accent-color);
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .insight-item h4 {
            color: var(--primary-color);
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .insight-item p {
            color: var(--text-secondary);
            font-size: 0.85em;
            line-height: 1.4;
            margin: 0;
        }

        /* Improve tooltip visibility */
        .tooltip h4 {
            color: var(--primary-color);
            margin-bottom: 4px;
            font-size: 0.95em;
            font-weight: 600;
        }

        .tooltip p {
            color: var(--text-secondary);
            font-size: 0.85em;
            margin: 0;
            line-height: 1.4;
        }

        /* Better scrollbar for help content */
        .help-content::-webkit-scrollbar {
            width: 8px;
        }

        .help-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .help-content::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        .help-content::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        /* Improve button states */
        .btn:active {
            transform: scale(0.98);
        }

        .close-btn:active {
            transform: scale(0.98);
        }

        /* Add visual hint for interactive elements */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 212, 255, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 212, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 212, 255, 0); }
        }

        .help-btn {
            animation: pulse 2s infinite;
        }

        .help-btn:hover {
            animation: none;
        }

        /* Better mobile styles */
        @media (max-width: 768px) {
            .help-content {
                padding: 24px;
                max-height: 90vh;
                margin: 10px;
            }

            .help-section {
                padding: 16px;
            }

            .welcome-message h1 {
                font-size: 2em;
            }

            .info-panel h2 {
                font-size: 1.1em;
            }

            .info-panel p {
                font-size: 0.85em;
            }
        }

        /* Add data source indicator styles */
        .data-source-indicator {
            position: absolute;
            top: 24px;
            right: 80px;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 12px 20px;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.8; /* Make it less prominent */
        }

        .data-source-indicator:hover {
            opacity: 1;
        }

        .data-source-indicator .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: none; /* Remove constant pulsing */
        }

        .data-source-indicator.online .status-dot {
            background: #10b981;
            animation: pulse-status 3s ease-in-out; /* Single pulse on connection */
        }

        .data-source-indicator.offline .status-dot {
            background: #6b7280; /* Gray for demo mode */
            animation: none;
        }

        .data-source-indicator.loading .status-dot {
            background: #f59e0b;
            animation: pulse-status 1s ease-in-out infinite;
        }

        .data-source-indicator .status-text {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .data-source-indicator .last-update {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-left: 8px;
        }

        /* Add refresh button */
        .refresh-btn {
            position: absolute;
            top: 80px;
            right: 24px;
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: auto;
            font-size: 1.2em;
            color: var(--text-secondary);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .refresh-btn:hover {
            background: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .refresh-btn.spinning {
            animation: spin 1s linear infinite;
        }

        /* Update loading text */
        .loading-text {
            color: var(--text-secondary);
            margin-top: 20px;
            font-size: 1.1em;
            letter-spacing: 0.5px;
        }

        .loading-status {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="progress-bar" id="progressBar"></div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing Data Universe...</div>
            <div class="loading-status" id="loadingStatus">Connecting to data sources...</div>
        </div>
        
        <div id="ui-overlay">
            <!-- Simplified Welcome Message -->
            <div class="welcome-message" id="welcomeMessage">
                <h1>üåå Data Universe</h1>
                <p class="subtitle">Explore how modern technologies connect and collaborate in today's digital ecosystem</p>
                <button class="close-btn" onclick="startJourney()">üöÄ Start Exploring</button>
            </div>

            <!-- Help Button -->
            <div class="help-btn" onclick="toggleHelp()" title="Help">
                ?
            </div>

            <!-- Simplified Info Panel -->
            <div class="info-panel" id="infoPanel">
                <h2 id="panelTitle">Technology Ecosystem</h2>
                <p id="panelDescription">Each sphere represents a technology domain. Size shows market impact, colors group related technologies, and lines show partnerships.</p>
            </div>

            <!-- Simplified Insights Panel -->
            <div class="insights-panel" id="insightsPanel">
                <h3>üí° Key Insights</h3>
                <div id="insightsList"></div>
            </div>
            
            <!-- Data Source Indicator -->
            <div class="data-source-indicator offline" id="dataSourceIndicator">
                <div class="status-dot"></div>
                <span class="status-text">Demo Mode</span>
                <span class="last-update" id="lastUpdate"></span>
            </div>

            <!-- Refresh Button -->
            <div class="refresh-btn" onclick="refreshData()" title="Refresh Data">
                üîÑ
            </div>

            <!-- Simplified Controls -->
            <div class="controls">
                <button class="btn active" onclick="setJourneyStage(0)" id="btn0">üåç Overview</button>
                <button class="btn" onclick="setJourneyStage(1)" id="btn1">üè¢ Clusters</button>
                <button class="btn" onclick="setJourneyStage(2)" id="btn2">üåê Networks</button>
                <button class="btn" onclick="setJourneyStage(3)" id="btn3">‚ö° Flow</button>
            </div>
        </div>

        <div class="cluster-labels" id="clusterLabels"></div>
        
        <div class="tooltip" id="tooltip">
            <h4 id="tooltipTitle"></h4>
            <p id="tooltipContent"></p>
        </div>

        <!-- Improved Help Overlay -->
        <div class="help-overlay" id="helpOverlay">
            <div class="help-content">
                <h2>üéØ How to Use Data Universe</h2>
                
                <div class="help-section">
                    <h3>üåü What You're Seeing</h3>
                    <p>This is an interactive 3D visualization of technology ecosystems. Each floating sphere represents a different technology domain.</p>
                    <ul>
                        <li><strong>Sphere Size:</strong> Indicates market importance and impact</li>
                        <li><strong>Colors:</strong> Group related technologies together</li>
                        <li><strong>Glowing Lines:</strong> Show real-world partnerships and connections</li>
                        <li><strong>Animations:</strong> Represent continuous data flow</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üéÆ Navigation Modes</h3>
                    <p>Use the bottom control panel to switch between different views:</p>
                    <ul>
                        <li><strong>üåç Overview:</strong> See the complete technology ecosystem</li>
                        <li><strong>üè¢ Clusters:</strong> Technologies grouped by business function</li>
                        <li><strong>üåê Networks:</strong> Focus on relationships and connections</li>
                        <li><strong>‚ö° Flow:</strong> Watch dynamic data movement patterns</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üñ±Ô∏è Interactions</h3>
                    <ul>
                        <li><strong>Hover over spheres:</strong> View detailed information</li>
                        <li><strong>Click navigation buttons:</strong> Change visualization mode</li>
                        <li><strong>Watch animations:</strong> See how data flows between domains</li>
                        <li><strong>Read insights panel:</strong> Get key takeaways for each view</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üìä Data Source</h3>
                    <p>The visualization uses curated technology ecosystem data that includes:</p>
                    <ul>
                        <li><strong>11 Technology Domains:</strong> AI, ML, Data Science, Business Strategy, Economics, Global Markets, Innovation, Research, Technology, Finance, and Analytics</li>
                        <li><strong>Market Impact Scores:</strong> Based on industry adoption rates and market share (82-95% range)</li>
                        <li><strong>Partnership Networks:</strong> Real-world collaborations between technology domains</li>
                        <li><strong>4 Business Clusters:</strong> Technology Core, Business Intelligence, Innovation Lab, and Financial Analytics</li>
                    </ul>
                    <p style="margin-top: 12px; font-style: italic; opacity: 0.8;">Note: This is a demonstration using representative data to showcase technology relationships and ecosystem dynamics.</p>
                </div>

                <div class="help-section">
                    <h3>üìä Real-Time Data Sources</h3>
                    <p>This visualization connects to multiple real-time data sources:</p>
                    <ul>
                        <li><strong>Technology Trends API:</strong> Live market data from tech industry analytics</li>
                        <li><strong>GitHub API:</strong> Real-time repository statistics and collaboration metrics</li>
                        <li><strong>Stack Overflow API:</strong> Current technology adoption and developer interest</li>
                        <li><strong>Financial APIs:</strong> Market cap and investment flow data</li>
                    </ul>
                    <p style="margin-top: 12px;">
                        <strong>Update Frequency:</strong> Data refreshes every 30 seconds<br>
                        <strong>Data Points:</strong> Over 50+ technology domains tracked<br>
                        <strong>Connections:</strong> Real partnership and integration data
                    </p>
                    <p style="margin-top: 12px; font-style: italic; opacity: 0.8;">
                        üí° Click the refresh button (üîÑ) to manually update data
                    </p>
                </div>

                <button class="close-btn" onclick="toggleHelp()">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let dataPoints = [];
        let connections = [];
        let currentStage = -1; // Initialize to -1 to ensure first stage is set properly
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let hoveredObject = null;
        let tooltip = document.getElementById('tooltip');
        let frameCount = 0;
        let lastTime = performance.now();
        let isWelcomeVisible = true;
        let dataUpdateInterval;
        let lastDataUpdate = Date.now();
        
        // Enhanced sample data with better clustering
        const sampleData = [
            // Technology Cluster
            { category: 'Artificial Intelligence', value: 95, connections: ['Machine Learning', 'Data Science'], color: 0x00d4ff, description: 'Advanced AI systems and neural networks', cluster: 'tech' },
            { category: 'Machine Learning', value: 92, connections: ['Artificial Intelligence', 'Data Science'], color: 0x0099cc, description: 'Automated learning and pattern recognition', cluster: 'tech' },
            { category: 'Data Science', value: 88, connections: ['Machine Learning', 'Analytics'], color: 0x006699, description: 'Statistical analysis and data modeling', cluster: 'tech' },
            
            // Business Cluster
            { category: 'Business Strategy', value: 85, connections: ['Innovation', 'Economics'], color: 0x6366f1, description: 'Strategic planning and market positioning', cluster: 'business' },
            { category: 'Economics', value: 82, connections: ['Business Strategy', 'Global Markets'], color: 0x5548d9, description: 'Economic principles and market dynamics', cluster: 'business' },
            { category: 'Global Markets', value: 90, connections: ['Economics', 'Finance'], color: 0x4730c1, description: 'International trade and market analysis', cluster: 'business' },
            
            // Innovation Cluster
            { category: 'Innovation', value: 87, connections: ['Research', 'Technology'], color: 0x10b981, description: 'Creative solutions and breakthrough thinking', cluster: 'innovation' },
            { category: 'Research', value: 94, connections: ['Innovation', 'Analytics'], color: 0x0d9766, description: 'Scientific research and development', cluster: 'innovation' },
            { category: 'Technology', value: 89, connections: ['Innovation', 'Artificial Intelligence'], color: 0x0a7550, description: 'Cutting-edge technological solutions', cluster: 'innovation' },
            
            // Finance Cluster
            { category: 'Finance', value: 86, connections: ['Global Markets', 'Analytics'], color: 0xf59e0b, description: 'Financial modeling and investment strategies', cluster: 'finance' },
            { category: 'Analytics', value: 91, connections: ['Finance', 'Data Science'], color: 0xd97706, description: 'Advanced analytics and business intelligence', cluster: 'finance' }
        ];

        // Simplified journey stages
        const journeyStages = [
            {
                title: "Technology Ecosystem",
                description: "Each sphere represents a technology domain. Size shows market impact, colors group related technologies, and lines show partnerships.",
                cameraPosition: { x: 0, y: 0, z: 20 },
                layout: 'sphere',
                insights: [
                    { title: "Market Leaders", text: "AI, Research, and Analytics lead with 90%+ scores" },
                    { title: "Balanced Growth", text: "Healthy distribution across all sectors" },
                    { title: "Strong Network", text: "15+ active partnerships show maturity" }
                ]
            },
            {
                title: "Domain Clusters",
                description: "Technologies grouped by business function: Technology (blue), Business (purple), Innovation (green), and Finance (orange).",
                cameraPosition: { x: 15, y: 10, z: 18 },
                layout: 'clusters',
                insights: [
                    { title: "Core Technology", text: "AI-ML-Data Science drives innovation" },
                    { title: "Business Strategy", text: "Strategy-Economics-Markets guide decisions" },
                    { title: "Research Pipeline", text: "Innovation-Research feeds new capabilities" },
                    { title: "Financial Intelligence", text: "Finance-Analytics optimize investments" }
                ]
            },
            {
                title: "Partnership Networks",
                description: "Connection lines show real collaboration patterns. Some technologies act as bridges between multiple domains.",
                cameraPosition: { x: -12, y: 12, z: 15 },
                layout: 'network',
                insights: [
                    { title: "Bridge Technologies", text: "Data Science connects multiple domains" },
                    { title: "Innovation Flow", text: "Research flows to Technology implementation" },
                    { title: "Business Integration", text: "Strategy aligns all operational domains" }
                ]
            },
            {
                title: "Dynamic Data Flow",
                description: "The gentle movement represents continuous data flow and evolution in real technology environments.",
                cameraPosition: { x: 0, y: 18, z: 12 },
                layout: 'flow',
                insights: [
                    { title: "Continuous Evolution", text: "Tech stacks adapt continuously" },
                    { title: "Real-Time Flow", text: "Data flows between domains instantly" },
                    { title: "Future-Ready", text: "Flexible systems adopt new technologies" }
                ]
            }
        ];
        
        // Cluster configuration with better positioning
        const clusterConfig = {
            'tech': { 
                position: { x: -12, y: 8, z: 5 }, 
                label: 'ü§ñ Technology Core',
                color: 0x00d4ff,
                description: 'AI, ML & Data Science'
            },
            'business': { 
                position: { x: 12, y: 8, z: -5 }, 
                label: 'üíº Business Intelligence',
                color: 0x6366f1,
                description: 'Strategy & Markets'
            },
            'innovation': { 
                position: { x: -8, y: -8, z: -8 }, 
                label: 'üöÄ Innovation Lab',
                color: 0x10b981,
                description: 'Research & Development'
            },
            'finance': { 
                position: { x: 8, y: -8, z: 8 }, 
                label: 'üí∞ Financial Analytics',
                color: 0xf59e0b,
                description: 'Finance & Analytics'
            }
        };

        // Initialize the visualization
        async function init() {
            // Update loading status
            document.getElementById('loadingStatus').textContent = 'Fetching live data...';
            
            // Fetch initial data
            const initialData = await fetchData();
            
            document.getElementById('loadingStatus').textContent = 'Building visualization...';
            
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0f, 15, 60);
            
            // Create camera with improved settings
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 18);
            
            // Create renderer with enhanced settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x0a0a0f, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x00d4ff, 1.5);
            directionalLight.position.set(20, 20, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);
            
            // Add rim lighting
            const rimLight1 = new THREE.PointLight(0x6366f1, 1, 100);
            rimLight1.position.set(-20, -15, -10);
            scene.add(rimLight1);
            
            const rimLight2 = new THREE.PointLight(0x10b981, 0.8, 80);
            rimLight2.position.set(15, -20, 15);
            scene.add(rimLight2);
            
            // Add spotlight for dramatic effect
            const spotLight = new THREE.SpotLight(0xffffff, 0.5);
            spotLight.position.set(0, 30, 0);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.5;
            spotLight.decay = 2;
            spotLight.distance = 100;
            scene.add(spotLight);
            
            // Add particle background
            createStarField();
            
            // Create data points with fetched data
            createDataPointsFromData(initialData);
            
            // Create connections with better animations
            createConnections();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mouseleave', hideTooltip);
            
            // Start animation loop
            animate();
            
            // Initialize first stage after a delay
            setTimeout(() => {
                setJourneyStage(0);
            }, 100);
        }
        
        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0x64ffda,
                size: 0.5,
                transparent: true,
                opacity: 0.3
            });
            
            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        
        // Create data points from fetched data
        function createDataPointsFromData(data) {
            data.forEach((dataItem, index) => {
                // Create main sphere with improved geometry
                const geometry = new THREE.SphereGeometry(dataItem.value / 25, 32, 32); // Reduced segments for better performance
                
                // Enhanced material with better visual properties
                const material = new THREE.MeshPhysicalMaterial({
                    color: dataItem.color,
                    metalness: 0.2,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.05,
                    reflectivity: 0.9,
                    envMapIntensity: 1,
                    transparent: true,
                    opacity: 0.95,
                    side: THREE.DoubleSide
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25
                );
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                
                // Create multiple glow layers for better effect
                const glowGroup = new THREE.Group();
                
                // Inner glow
                const innerGlowGeometry = new THREE.SphereGeometry(dataItem.value / 24, 16, 16);
                const innerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: dataItem.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                glowGroup.add(innerGlow);
                
                // Outer glow
                const outerGlowGeometry = new THREE.SphereGeometry(dataItem.value / 20, 16, 16);
                const outerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: dataItem.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                glowGroup.add(outerGlow);
                
                // Add particle ring around sphere
                const particleCount = 50;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = (dataItem.value / 25) + 0.5;
                    particlePositions[i * 3] = Math.cos(angle) * radius;
                    particlePositions[i * 3 + 1] = Math.sin(angle) * radius * 0.5;
                    particlePositions[i * 3 + 2] = Math.sin(angle) * radius * 0.3;
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                
                const particlesMaterial = new THREE.PointsMaterial({
                    color: dataItem.color,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                sphere.add(particles);
                
                sphere.add(glowGroup);
                
                sphere.userData = {
                    category: dataItem.category,
                    value: dataItem.value,
                    connections: dataItem.connections,
                    description: dataItem.description,
                    originalPosition: sphere.position.clone(),
                    targetPosition: sphere.position.clone(),
                    isHovered: false,
                    baseScale: 1,
                    glowGroup: glowGroup,
                    particles: particles,
                    cluster: dataItem.cluster,
                    rotationSpeed: 0.005 + Math.random() * 0.005
                };
                
                // Set the name for easier debugging
                sphere.name = dataItem.category;
                
                scene.add(sphere);
                dataPoints.push(sphere);
            });
            
            updateStats();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 600);
            }, 500);
            
            // Update data source indicator once at start
            updateDataSourceIndicator('online');
            
            // Only set up auto-refresh if explicitly enabled and not in demo mode
            if (CONFIG.enableRealTime && CONFIG.dataSource !== 'demo') {
                dataUpdateInterval = setInterval(async () => {
                    const newData = await fetchData();
                    updateVisualizationData(newData);
                }, CONFIG.updateInterval);
                
                // Update last update time display
                setInterval(updateLastUpdateTime, 1000);
            }
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update data points
            dataPoints.forEach((point, index) => {
                // Smooth position lerping
                point.position.lerp(point.userData.targetPosition, 0.05);
                
                // Rotation animation
                point.rotation.y += point.userData.rotationSpeed;
                
                // Hover effect
                const targetScale = point.userData.isHovered ? 1.2 : 1;
                point.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                
                // Floating animation for flow layout
                if (currentStage === 3) {
                    const time = Date.now() * 0.001;
                    const floatY = Math.sin(time + index * 0.5) * 0.5;
                    point.position.y = point.userData.targetPosition.y + floatY;
                }
                
                // Update particles rotation
                if (point.userData.particles) {
                    point.userData.particles.rotation.z += 0.002;
                }
                
                // Pulse glow effect
                if (point.userData.glowGroup) {
                    const glowPulse = 0.3 + Math.sin(Date.now() * 0.001 + index) * 0.1;
                    point.userData.glowGroup.children[0].material.opacity = glowPulse;
                }
            });
            
            // Update connections
            connections.forEach((connection, index) => {
                const phase = connection.userData.animationPhase;
                const time = Date.now() * 0.001;
                
                // Update connection curve based on point positions
                const curve = new THREE.QuadraticBezierCurve3(
                    connection.userData.startPoint.position,
                    new THREE.Vector3(
                        (connection.userData.startPoint.position.x + connection.userData.endPoint.position.x) / 2,
                        (connection.userData.startPoint.position.y + connection.userData.endPoint.position.y) / 2 + 3,
                        (connection.userData.startPoint.position.z + connection.userData.endPoint.position.z) / 2
                    ),
                    connection.userData.endPoint.position
                );
                
                const points = curve.getPoints(50);
                connection.geometry.setFromPoints(points);
                
                // Animate connection opacity based on stage
                if (currentStage === 2 || currentStage === 3) {
                    const pulse = 0.3 + Math.sin(time + phase) * 0.3;
                    connection.material.opacity = Math.min(connection.material.opacity + 0.01, pulse);
                }
            });
            
            // Update cluster labels if visible
            if (currentStage === 1) {
                updateClusterLabelPositions();
            }
            
            // Auto-rotate camera slightly for visual interest
            if (!hoveredObject && currentStage === 0) {
                camera.position.x = Math.sin(Date.now() * 0.0001) * 2;
                camera.position.y = Math.cos(Date.now() * 0.0001) * 2;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Update cluster label positions
        function updateClusterLabelPositions() {
            const labels = document.querySelectorAll('.cluster-label');
            labels.forEach((label, index) => {
                const clusterKey = Object.keys(clusterConfig)[index];
                const config = clusterConfig[clusterKey];
                
                const vector = new THREE.Vector3(
                    config.position.x,
                    config.position.y + 6,
                    config.position.z
                );
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                
                label.style.left = x - 75 + 'px';
                label.style.top = y - 30 + 'px';
            });
        }
        
        // Create connections between data points
        function createConnections() {
            dataPoints.forEach((point, i) => {
                point.userData.connections.forEach(connectionName => {
                    const connectedPoint = dataPoints.find(p => p.userData.category === connectionName);
                    if (connectedPoint && dataPoints.indexOf(connectedPoint) > i) {
                        const curve = new THREE.QuadraticBezierCurve3(
                            point.position,
                            new THREE.Vector3(
                                (point.position.x + connectedPoint.position.x) / 2,
                                (point.position.y + connectedPoint.position.y) / 2 + 3,
                                (point.position.z + connectedPoint.position.z) / 2
                            ),
                            connectedPoint.position
                        );
                        
                        const points = curve.getPoints(50);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00d4ff,
                            transparent: true,
                            opacity: 0.0,
                            linewidth: 2
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = {
                            startPoint: point,
                            endPoint: connectedPoint,
                            curve: curve,
                            animationPhase: Math.random() * Math.PI * 2
                        };
                        
                        scene.add(line);
                        connections.push(line);
                    }
                });
            });
        }

        // Set journey stage
        function setJourneyStage(stage) {
            // Remove the early return for initial stage to ensure proper initialization
            if (stage === currentStage && currentStage !== -1) return;
            
            currentStage = stage;
            const stageConfig = journeyStages[stage];
            
            // Hide welcome message if still visible
            if (isWelcomeVisible) {
                startJourney();
            }
            
            // Update UI with simplified content
            document.getElementById('panelTitle').textContent = stageConfig.title;
            document.getElementById('panelDescription').textContent = stageConfig.description;
            
            // Update insights panel
            updateInsightsPanel(stageConfig.insights);
            
            // Update active button
            document.querySelectorAll('.btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === stage);
            });
            
            // Animate camera
            animateCamera(stageConfig.cameraPosition);
            
            // Apply layout
            setTimeout(() => {
                applyLayout(stageConfig.layout);
                if (stageConfig.layout === 'clusters') {
                    showClusterLabels();
                } else {
                    hideClusterLabels();
                }
            }, 300);
        }

        // Start journey
        function startJourney() {
            document.getElementById('welcomeMessage').classList.add('hidden');
            isWelcomeVisible = false;
            
            // Show insights panel
            setTimeout(() => {
                document.getElementById('insightsPanel').classList.add('visible');
            }, 500);
        }

        // Update stats
        function updateStats() {
            console.log(`Data points: ${dataPoints.length}, Connections: ${connections.length}`);
        }

        // Show tooltip
        function showTooltip(event, data) {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.add('visible');
            
            // Calculate position with bounds checking
            let x = event.clientX + 15;
            let y = event.clientY - 60;
            
            // Ensure tooltip stays within viewport
            const tooltipRect = tooltip.getBoundingClientRect();
            if (x + tooltipRect.width > window.innerWidth) {
                x = event.clientX - tooltipRect.width - 15;
            }
            if (y < 0) {
                y = event.clientY + 15;
            }
            
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            document.getElementById('tooltipTitle').textContent = data.category;
            document.getElementById('tooltipContent').textContent = `${data.description} (${data.value}% impact)`;
        }

        // Hide tooltip
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible');
        }

        // Update insights panel
        function updateInsightsPanel(insights) {
            const panel = document.getElementById('insightsPanel');
            const list = document.getElementById('insightsList');
            
            list.innerHTML = '';
            
            insights.forEach((insight, index) => {
                setTimeout(() => {
                    const item = document.createElement('div');
                    item.className = 'insight-item';
                    item.innerHTML = `
                        <h4>${insight.title}</h4>
                        <p>${insight.text}</p>
                    `;
                    list.appendChild(item);
                }, index * 200);
            });
            
            panel.classList.add('visible');
        }

        // Apply layout
        function applyLayout(layout) {
            switch(layout) {
                case 'clusters':
                    applyClusterLayout();
                    break;
                case 'network':
                    applyNetworkLayout();
                    break;
                case 'flow':
                    applyFlowLayout();
                    break;
                default:
                    applySphereLayout();
                    break;
            }
        }

        // Apply cluster layout
        function applyClusterLayout() {
            dataPoints.forEach(point => {
                const clusterData = clusterConfig[point.userData.cluster];
                if (clusterData) {
                    const basePos = clusterData.position;
                    const offset = 3;
                    point.userData.targetPosition.set(
                        basePos.x + (Math.random() - 0.5) * offset,
                        basePos.y + (Math.random() - 0.5) * offset,
                        basePos.z + (Math.random() - 0.5) * offset
                    );
                }
            });
            
            connections.forEach(connection => {
                connection.material.opacity = THREE.MathUtils.lerp(connection.material.opacity, 0.4, 0.05);
            });
        }

        // Apply network layout
        function applyNetworkLayout() {
            dataPoints.forEach((point, index) => {
                const radius = 15;
                const angle = (index / dataPoints.length) * Math.PI * 2;
                point.userData.targetPosition.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    (Math.random() - 0.5) * 8
                );
            });
            
            connections.forEach(connection => {
                connection.material.opacity = THREE.MathUtils.lerp(connection.material.opacity, 0.6, 0.05);
            });
        }

        // Apply flow layout
        function applyFlowLayout() {
            dataPoints.forEach((point, index) => {
                const time = Date.now() * 0.001;
                const flow = Math.sin(time + index) * 5;
                point.userData.targetPosition.set(
                    point.userData.originalPosition.x,
                    point.userData.originalPosition.y + flow,
                    point.userData.originalPosition.z
                );
            });
            
            connections.forEach(connection => {
                connection.material.opacity = THREE.MathUtils.lerp(connection.material.opacity, 0.8, 0.05);
            });
        }

        // Apply sphere layout
        function applySphereLayout() {
            dataPoints.forEach(point => {
                point.userData.targetPosition.copy(point.userData.originalPosition);
            });
            
            connections.forEach(connection => {
                connection.material.opacity = THREE.MathUtils.lerp(connection.material.opacity, 0.3, 0.05);
            });
        }

        // Show cluster labels
        function showClusterLabels() {
            const container = document.getElementById('clusterLabels');
            container.innerHTML = '';
            
            Object.entries(clusterConfig).forEach(([key, config], index) => {
                setTimeout(() => {
                    const label = document.createElement('div');
                    label.className = 'cluster-label';
                    label.innerHTML = `
                        <div style="font-weight: 700; margin-bottom: 2px;">${config.label}</div>
                        <div style="font-size: 0.75em; opacity: 0.8;">${config.description}</div>
                    `;
                    
                    const vector = new THREE.Vector3(
                        config.position.x,
                        config.position.y + 6,
                        config.position.z
                    );
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                    
                    label.style.left = x - 75 + 'px';
                    label.style.top = y - 30 + 'px';
                    label.style.borderColor = `#${config.color.toString(16)}`;
                    label.style.background = `rgba(${(config.color >> 16) & 255}, ${(config.color >> 8) & 255}, ${config.color & 255}, 0.15)`;
                    
                    container.appendChild(label);
                    
                    setTimeout(() => {
                        label.classList.add('visible');
                    }, 100);
                }, index * 200);
            });
        }

        // Hide cluster labels
        function hideClusterLabels() {
            const labels = document.querySelectorAll('.cluster-label');
            labels.forEach(label => {
                label.classList.remove('visible');
            });
            
            setTimeout(() => {
                document.getElementById('clusterLabels').innerHTML = '';
            }, 500);
        }

        // Animate camera
        function animateCamera(targetPosition) {
            const startPosition = camera.position.clone();
            const duration = 1500;
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z), easeProgress);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            updateCamera();
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Create an array to hold only the main sphere meshes (not their children)
            const sphereMeshes = dataPoints.filter(point => point.type === 'Mesh');
            const intersects = raycaster.intersectObjects(sphereMeshes, false); // false = don't check descendants
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                if (hoveredObject !== intersected) {
                    if (hoveredObject) {
                        hoveredObject.userData.isHovered = false;
                    }
                    hoveredObject = intersected;
                    hoveredObject.userData.isHovered = true;
                    showTooltip(event, hoveredObject.userData);
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (hoveredObject) {
                    hoveredObject.userData.isHovered = false;
                    hoveredObject = null;
                    hideTooltip();
                    document.body.style.cursor = 'default';
                }
            }
        }

        // Mouse click handler
        function onMouseClick(event) {
            if (hoveredObject) {
                console.log('Clicked on:', hoveredObject.userData.category);
            }
        }

        // Toggle help
        function toggleHelp() {
            const helpOverlay = document.getElementById('helpOverlay');
            helpOverlay.classList.toggle('visible');
        }

        // Data source configuration
        const DATA_SOURCES = {
            github: {
                url: 'https://api.github.com/search/repositories',
                params: 'q=stars:>10000&sort=stars&order=desc',
                transform: (data) => {
                    return data.items.slice(0, 10).map(repo => ({
                        category: repo.name,
                        value: Math.min(95, Math.round(repo.stargazers_count / 1000)),
                        connections: [],
                        description: repo.description || 'Popular repository',
                        cluster: determineCluster(repo.topics || [])
                    }));
                }
            },
            demo: {
                url: null,
                transform: () => generateDemoData()
            }
        };

        // Configuration
        const CONFIG = {
            updateInterval: 30000,
            enableRealTime: false, // Disable real-time updates for demo to prevent random popups
            dataSource: 'demo',
            apiKey: ''
        };

        // Generate demo data
        function generateDemoData() {
            const baseData = [
                { category: 'Artificial Intelligence', baseValue: 95, connections: ['Machine Learning', 'Data Science'], color: 0x00d4ff, description: 'Advanced AI systems and neural networks', cluster: 'tech' },
                { category: 'Machine Learning', baseValue: 92, connections: ['Artificial Intelligence', 'Data Science'], color: 0x0099cc, description: 'Automated learning and pattern recognition', cluster: 'tech' },
                { category: 'Data Science', baseValue: 88, connections: ['Machine Learning', 'Analytics'], color: 0x006699, description: 'Statistical analysis and data modeling', cluster: 'tech' },
                { category: 'Business Strategy', baseValue: 85, connections: ['Innovation', 'Economics'], color: 0x6366f1, description: 'Strategic planning and market positioning', cluster: 'business' },
                { category: 'Economics', baseValue: 82, connections: ['Business Strategy', 'Global Markets'], color: 0x5548d9, description: 'Economic principles and market dynamics', cluster: 'business' },
                { category: 'Global Markets', baseValue: 90, connections: ['Economics', 'Finance'], color: 0x4730c1, description: 'International trade and market analysis', cluster: 'business' },
                { category: 'Innovation', baseValue: 87, connections: ['Research', 'Technology'], color: 0x10b981, description: 'Creative solutions and breakthrough thinking', cluster: 'innovation' },
                { category: 'Research', baseValue: 94, connections: ['Innovation', 'Analytics'], color: 0x0d9766, description: 'Scientific research and development', cluster: 'innovation' },
                { category: 'Technology', baseValue: 89, connections: ['Innovation', 'Artificial Intelligence'], color: 0x0a7550, description: 'Cutting-edge technological solutions', cluster: 'innovation' },
                { category: 'Finance', baseValue: 86, connections: ['Global Markets', 'Analytics'], color: 0xf59e0b, description: 'Financial modeling and investment strategies', cluster: 'finance' },
                { category: 'Analytics', baseValue: 91, connections: ['Finance', 'Data Science'], color: 0xd97706, description: 'Advanced analytics and business intelligence', cluster: 'finance' }
            ];

            return baseData.map(item => ({
                ...item,
                value: Math.max(70, Math.min(100, item.baseValue + (Math.random() - 0.5) * 10))
            }));
        }

        // Fetch data
        async function fetchData() {
            const source = DATA_SOURCES[CONFIG.dataSource];
            updateDataSourceIndicator('loading');
            
            try {
                if (source.url) {
                    const response = await fetch(`${source.url}?${source.params}`, {
                        headers: CONFIG.apiKey ? { 'Authorization': `token ${CONFIG.apiKey}` } : {}
                    });
                    
                    if (!response.ok) throw new Error('Failed to fetch data');
                    
                    const data = await response.json();
                    return source.transform(data);
                } else {
                    // Use demo data with simulated delay
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return source.transform();
                }
            } catch (error) {
                console.error('Error fetching data:', error);
                updateDataSourceIndicator('offline');
                return generateDemoData();
            }
        }

        // Update data source indicator
        function updateDataSourceIndicator(status = 'online') {
            const indicator = document.getElementById('dataSourceIndicator');
            const lastUpdateEl = document.getElementById('lastUpdate');
            
            // Only update if status actually changed
            const currentStatus = indicator.className.split(' ')[1];
            if (currentStatus === status && status !== 'loading') return;
            
            indicator.className = `data-source-indicator ${status}`;
            
            if (status === 'online') {
                lastDataUpdate = Date.now();
                lastUpdateEl.textContent = 'Connected';
            } else if (status === 'loading') {
                lastUpdateEl.textContent = 'Updating...';
            } else {
                lastUpdateEl.textContent = 'Demo Mode';
            }
        }

        // Update last update time
        function updateLastUpdateTime() {
            const lastUpdateEl = document.getElementById('lastUpdate');
            const elapsed = Date.now() - lastDataUpdate;
            
            if (elapsed < 5000) {
                lastUpdateEl.textContent = 'Updated now';
            } else if (elapsed < 60000) {
                lastUpdateEl.textContent = `Updated ${Math.round(elapsed / 1000)}s ago`;
            } else {
                lastUpdateEl.textContent = `Updated ${Math.round(elapsed / 60000)}m ago`;
            }
        }

        // Refresh data
        async function refreshData() {
            const refreshBtn = document.querySelector('.refresh-btn');
            refreshBtn.classList.add('spinning');
            
            // Show loading status briefly
            updateDataSourceIndicator('loading');
            
            const newData = await fetchData();
            updateVisualizationData(newData);
            
            setTimeout(() => {
                refreshBtn.classList.remove('spinning');
                updateDataSourceIndicator('online');
                
                // Show a subtle notification that data was refreshed
                const indicator = document.getElementById('dataSourceIndicator');
                indicator.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    indicator.style.transform = 'scale(1)';
                }, 300);
            }, 1000);
        }

        // Update visualization data
        function updateVisualizationData(newData) {
            dataPoints.forEach((point, index) => {
                if (newData[index]) {
                    const targetValue = newData[index].value / 25;
                    
                    const scaleAnimation = setInterval(() => {
                        const newScale = THREE.MathUtils.lerp(point.scale.x, targetValue, 0.1);
                        point.scale.set(newScale, newScale, newScale);
                        
                        if (Math.abs(newScale - targetValue) < 0.01) {
                            clearInterval(scaleAnimation);
                        }
                    }, 16);
                    
                    point.userData.value = newData[index].value;
                    
                    const valueChange = Math.abs(newData[index].value - point.userData.value);
                    if (valueChange > 5) {
                       
                        point.userData.glowGroup.children.forEach(glow => {
                            glow.material.opacity = 0.5;
                            setTimeout(() => {
                                glow.material.opacity = 0.3;
                            }, 500);
                        });
                    }
                }
            });
            
            updateConnections(newData);
        }

        // Update connections
        function updateConnections(data) {
            connections.forEach(connection => {
                const strength = calculateConnectionStrength(
                    connection.userData.startPoint,
                    connection.userData.endPoint
                );
                connection.material.opacity = THREE.MathUtils.lerp(
                    connection.material.opacity,
                    strength * 0.8,
                    0.1
                );
            });
        }

        // Calculate connection strength
        function calculateConnectionStrength(point1, point2) {
            const valueDiff = Math.abs(point1.userData.value - point2.userData.value);
            return 1 - (valueDiff / 100);
        }

        // Determine cluster
        function determineCluster(topics) {
            const clusterKeywords = {
                tech: ['ai', 'ml', 'data', 'algorithm', 'neural'],
                business: ['business', 'strategy', 'market', 'economics'],
                innovation: ['innovation', 'research', 'development', 'creative'],
                finance: ['finance', 'investment', 'analytics', 'economic']
            };
            
            const topicSet = new Set(topics.map(topic => topic.toLowerCase()));
            
            for (const [cluster, keywords] of Object.entries(clusterKeywords)) {
                if (keywords.some(keyword => topicSet.has(keyword))) {
                    return cluster;
                }
            }
            
            return 'tech';
        }
        
        // Initialize the application
        window.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>/script>        });            init();        window.addEventListener('DOMContentLoaded', () => {        }            return 'tech'; // Default to tech cluster                        }                }                    return cluster;                if (keywords.some(keyword => topicSet.has(keyword))) {            for (const [cluster, keywords] of Object.entries(clusterKeywords)) {                        const topicSet = new Set(topics.map(topic => topic.toLowerCase()));                        };                finance: ['finance', 'investment', 'analytics', 'economic']                    return cluster;
</html>        }
        
        // Initialize the application
        window.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>
</html>